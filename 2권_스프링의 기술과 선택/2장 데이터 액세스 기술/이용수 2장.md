# 데이터 액세스 기술
## 공통개념
### DAO 패턴
- DTO 또는 도메인 오브젝트만을 사용하는 인터페이스를 통해 데이터 액세스 기술을 외부에 노출하지 않도록 만드는 것
- 데이터 액세스 기술을 변경하거나 둘 이상의 기술을 혼합해서 사용하여도 클라이언트 코드에 영향을 주지 않고, 기술과 상관없는 단순 DTO나 엔티티 클래스를 사용하기 때문에 단위테스트에 용이

#### DAO 사용시 주의점
- 인터페이스를 통하여 접근하고 DI되도록 개발.
- 특정 데이터 액세스 기술에서만 쓰이는 메소드명은 지양(persist, merge)하고 일반적인 네이밍 사용(add, update)
- 데이터 액세스 중 발생하는 대부분의 예외는 복구 불가능 예외이므로 런타임 예외로 전환한 뒤 외부로 던지고, 메소드 선언부에 throws SQLException과 같은 내부 기술을 드러내는 예외를 직접 노출해선 안됨
- 중복키 예외 혹은 낙관적 락킹 등 비즈니스 로직에서 유의미하게 대처하는 예외들을 처리할 때는, 스프링에서 제공하는 데이터 예외 변환 서비스를 이용하는 것이 좋음(특정 기술이나 DB에 상관없이 일관된 예외로 추상화)

### DataSource
- 애플리케이션 서버와 DB사이의 실제 커넥션을 매번 새롭게 만드는 것은 비효율적
- 미리 정해진 갯수만큼의 DB커넥션을 풀에 준비해두고, 애플리케이션에서 요청시 풀에서 꺼내 하나씩 할당/이후 돌려받아 풀에 넣는 식의 기법을 활용
- 일부 데이터 액세스 기술은 자체 설정파일에 DB연결정보를 담게 해서 해당 기술내부에서 직접 DataSource를 생성하고 관리하는 경우가 있으나, 스프링에서는 DataSource를 하나의 독립된 빈으로 등록하는 것을 권장(스프링 데이터 액세스 기술의 다양한 서비스에서 Datasource를 활용해야하기 때문)

### JNDI/WAS DB 풀

대부분의 자바 서버는 자체적으로 DB 풀 서비스를 제공한다. 스프링 어플리케이션에서 직접 DB풀을 관리하지 않고 어플리케이션 외부 WAS가 관리하는 DB풀을 사용하기 위해서는, JNDI를 통해 서버의 DataSource에 접근해야 한다.

서버에 `jdbc/DefaultDS`라는 이름으로 등록된 서버의 데이터 소스가 있는 경우, 다음과 같은 설정으로 빈을 등록해주면 된다.
`<jee:jndi-lookup id="dataSource" jndi-name="jdbc/DefaultDS" />` 

## JDBC

JDBC는 자바의 데이터 액세스 기술의 기본이 되는 로우레벨의 API다. JDBC는 표준 인터페이스를 제공하고, 각 DB 벤더와 개발팀이 이 표준을 구현한 드라이버를 제공하기 때문에, SQL 호환성만 유지된다면 DB가 변경되어도 기존 JDB C코드를 그대로 사용할 수 있다.

하지만, 이러한 JDBC API를 직접 이용하는 것은 
1. 번잡한 코드(템플릿-콜백)
2. DB에 따라 일관성 없는 정보를 가진 채 던져지는 체크 예외(예외 추상화 및 전환)
3. SQL문을 코드에서 직접 문자열로 제공
4. 커넥션 관리를 직접함으로써 누수의 위험

과 같은 단점 때문에, 내부적으로 JDBC를 이용하는 고수준 기술을 이용하여 JDBC API를 간접적으로 이용한다.
(하이버네이트와 같은 ORM 기술도 내부적으로 JDBC API 이용)


## Spring JDBC
JDBC API를 직접 이용하면서 발생하는 문제를 다음과 같은 방식으로 해결해 준다.
1. SQL문을 준비하고 파라미터를 바인딩하여 마침내 실행하는 번거로운 과정을 템플릿 안으로 감춤
2. 일관적이지 않은 저수준 체크 예외를 일관된 고수준 예외로 추상화하고 런타임예외로 전환
3. 템플릿에서 커넥션관리를 해줌으로써 개발자가 자원 관리에 대해 신경쓰지 않도록 해줌

SimpleJdbcInsert, SimpleJdbcUpdate등을 사용하면, insert와 update쿼리를 직접 작성할 필요 없이 자동생성이 가능하다.

***현재는 SimpleJdbcTemplate은 deprecated되었고, 대신 NamedParameterJdbcTemplate이나 JdbcTemplate을 사용합니다.***

## iBatis

iBatis는 자바 오브젝트와 SQL 문 사이의 자동매핑 기능을 지원하는 ORM 프레임워크다. 
Spring JDBC Template과 비교했을 때 가장 큰 특징은 SQL을 자바 코드와 분리하여 별도의 XML 파일로 관리하도록 한다는 점이다.
iBatis에서 정한 문법에 맞는 xml파일에 쿼리들을 정의하고, JAVA코드에서는 xml파일에 정의한 쿼리를 식별할 수 있는 ID와 파라미터를 넘기는 방식  

## JPA
JavaPersistent API의 약자로 JavaEE와 JavaSE를 위한 영속성(persistence)관리와 O/R 매핑(ORM)을 위한 표준 기술이다.
Spring JDBC와 Mybatis가 데이터 액세스 로직을 처리하는데 많은 편의를 제공해주기는 하지만 SQL중심적인 개발 패러다임에서 벗어나지 못하고 있으며, 
JPA는 데이터베이스를 이용하더라도 어플리케이션 개발 과정이 SQL중심적인 관점에서 벗어날 수 있도록 하기 위해 만들어졌다.

RDB는 오브젝트를 영구 보관하기 위한 다양한 저장소 중 하나. 영구 저장소 중 가장 널리쓰이는 수단이 RDB이기 때문인지, 

```오브젝트를 객체지향적 설계관점에 입각해 설계 -> 단순히 이를 저장하기 위해 RDB 사용```하는 흐름보다는

```RDB 중심으로 테이블을 설계 -> 객체도 테이블에 맞추어 설계```하는 흐름이 주로 발생된다.

이는 객체지향과 관계형 데이터베이스에서 객체 또는 정보를 바라보고 연관짓는 관점이 크게 다르고, 이 차이를 메우기 위해 둘을 매핑하는 작업이 필요한데, 이 작업이 번거롭기 때문에 테이블 중심 설계/개발을 하는 것이 차라리 편하기 때문.  

### 객체지향과 관계형 데이터베이스 간 관점의 불일치
1. 상속
   - RDB에서도 객체의 상속관계와 유사한 슈퍼타입-서브타입 관계가 있기는 하지만 차이점이 있으므로, 객체를 상속관계로 설계한다면 CRUD작업 시 RDB의 슈퍼타입-서브타입 관계와 매핑할 수 있는 추가적인 코드를 작성해야한다.
   - 만약 JAVA 객체중심으로만 사고한다면, 단순히 여러 타입의 객체를 부모타입의 원소를 담을 수 있는 컬렉션에 add하는 작업임에도 RDB를 사용하면서 번거로운 매핑작업이 추가된다.
2. 연관관계
   - 객체는 참조를 사용해서 연관관계를 맺지만, 테이블끼리는 외래키를 이용하여 연관관계를 맺음
   - 객체 지향적 모델링은 연관객체의 참조를 가지므로 이를 이용하여 그래프를 순회하듯 자유로운 이동이 가능(eager/lazy loading 지원)
   - 테이블 중심 모델링은 연관객체의 식별자만을 가지므로, 그래프를 순회하듯이 탐색하는 것은 불가능하며, 연관객체의 식별자를 이용하여 검색하는 과정을 가져야함
      - 객체지향적 방식과 같이 순회하려면 필요한 모든 객체를 미리 eager loading해야함
      (그러나 정말 모든 객체를 로딩하는 것은 현실적으로 불가능하므로, 상황별로 유사한 테이블을 조회하는 쿼리를 반복해서 작성해야함)
      - DAO계층에서 넘겨받은 엔티티의 연관관계가 제대로 셋팅되었는지 신뢰할 수 없음
      - 서비스와 데이터액세스 계층이 진정한 의미로 분리되었다고 말하기 어려움
3. 데이터 식별 방법
   - 동일한 식별자를 가진 row를 두 번 조회한 뒤, 각 조회 결과를 == 연산자로 비교하면 어떻게 될까
   - 의미적으로 동일한 객체이지만 비교결과는 false. 만약 데이터를 자바 컬렉션에서 list.get(id)을 이용하여 가져왔다면 비교연산의 결과는 true였을 것

위와 같은 차이로 인해, 객체지향적 설계가 오히려 번거로운 매핑작업을 불러오는 상황이기 때문에, 객체지향적 언어를 사용하면서도 객체지향을 사용하지 않는다.
JPA는 위 차이점이 불러오는 번거로운 매핑 작업을 대신 혹은 더 간편하게 해줌으로써, 자바 오브젝트를 관리할 때 RDB 테이블을 중심에 두고 사고하는 것이 아니라, 
```마치 일반적인 자바 컬렉션에서 관리하듯이 사용할 수 있도록 하는 기술 ```

## 트랜잭션
### 트랜잭션 추상화와 동기화
스프링이 제공하는 트랜잭션 서비스는 트랜잭션 추상화와 트랜잭션 동기화 두 가지로 생각해볼 수 있다.

#### 트랜잭션 추상화
스프링은 데이터 액세스 기술과 트랜잭션 서비스 사이의 종속성을 제거하고 스프링이 제공하는 트랜잭션 추상 계층을 이용해서 트랜잭션 기능을 활용하도록 만들어준다.
이를 통해 트랜잭션 서비스의 종류나 환경이 바뀌더라도 트랜잭션을 사용하는 코드는 그대로 유지할 수 있는 유연성을 얻을 수 있다.
#### 트랜잭션 동기화
스프링의 트랜잭션 동기화는 트랜잭션을 일정 범위 안에서 유지해주고, 어디서든 자유롭게 접근할 수 있게 만들어준다.

### PlatformTransactionManager
스프링 트랜잭션 추상화의 핵심 인터페이스로서, 모든 스프링의 트랜잭션 기능과 코드는 이 인터페이스를 통해 ```일관된 형식```으로 이용할 수 있다.

PlatformTransactionManager는 트랜잭션 경계를 지정하는 데 사용한다. 트랜잭션 경계설정이란 트랜잭션이 어디서 시작하고 종료하는지, 종료할 때는 정상 종료(커밋)인지 비정상 종료(롤백)인지를 결정하는 것을 말한다.

스프링에서는 트랜잭션 시작/종료를 트랜잭션 전파 기법을 이용하여 자유롭게 조합하고 확장할 수 있으므로 트랜잭션을 시작한다는 의미의 begin()같은 메소드 네이밍 대신, 상황에 따른 적절한 트랜잭션을 가져온다는 의미인 getTransaction()메소드를 사용한다.
getTransaction()은 트랜잭션 속성에 따라 새로 시작하거나 진행중인 트랜잭션에 참여 / 진행 중인 트랜잭션을 무시한채 새로운 트랜잭션을 생성하는 등 상황에 따라 다르게 동작한다.

#### 트랜잭션 매니저의 종류
스프링이 제공하는 PlatformTransactionManager 구현 클래스
1. DataSourceTransactionManager
2. JpaTransactionManager
3. HibernateTransactionManager
4. JmsTransactionManager, CciTransactionManager
5. JtaTransactionManager

### 트랜잭션 경계설정 전략
트랜잭션의 시작과 종료가 되는 경계는 보통 서비스 계층 오브젝트의 메소드다.
비즈니스 로직이 거의 없어서 서비스 계층과 데이터 액세스 계층을 통합했다면, 통합된 계층의 메소드가 트랜잭션 경계가 될 것이다.
트랜잭션 경계를 설정하는 방법은 코드에 의한 프로그램적인 방법과, AOP를 이용한 선언적인 방법으로 구분할 수 있다.
전자는 트랜잭션을 다루는 코드를 직접 만들고, 후자는 AOP를 이용해 기존 코드에 트랜잭션 경계설정 기능을 부여해준다.

#### 코드에 의한 트랜잭션 경계설정
PlatformTransactionManager의 메소드를 직접 사용하여 경계설정을 할 수 있으나, JdbcTemplate과 유사하게 트랜잭션을 처리하기 위한 기반 코드들(try/catch문)을 작성하는 번거로움을 피하기 위해 TransactionTemplate을 이용할 수 있다.
대게 선언적 트랜잭션 방식만으로 충분하기 때문에, 코드로 직접 경계설정을 할 일이 흔치 않으나 이를 이해하고 있으면, 트랜잭션 적용과 관련된 버그를 해결할 때 도움이 될 수 있다.

#### 선언적 트랜잭션 경계설정
선언적 트랜잭션을 이용하면 코드에는 전혀 영향을 주지 않으면서 특정 메소드 실행 전후에 트랜잭션이 시작되고 종료되거나 기존 트랜잭션에 참여하도록 만들 수 있다.
간단한 설정으로 특정 부가기능을 임의의 타깃 오브젝트에 부여해줄 수 있는 프록시 AOP를 주로 활용한다.
AOP를 이용해 트랜잭션 기능을 부여할 때는
1. 설정파일에 명시적으로 포인트컷과 어드바이스를 등록하거나
2. @Transactional 어노테이션을 이용하는 방법 

중 하나를 사용한다.

### 프록시 모드: 인터페이스와 클래스
스프링의 AOP는 기본적으로 다이내믹 프록시 기법을 이용해 동작한다. 다이내믹 프록시를 적용하려면 인터페이스가 있어야 한다.
특별한 경우에 인터페이스를 구현하지 않은 클래스에 트랜잭션을 적용해야 한다면, 스프링이 지원하는 클래스 프록시 모드(CGLib 사용)를 사용하면 된다.
- aop/tx 스키마 태그의 클래스 프록시 설정
   - ```<aop:config proxy-target-class="true">```
- @Transactional의 클래스 프록시 설정
   - ```<tx:annotation-driven proxy-target-class="true" />```

@Transactional은 클래스에 부여해야 한다.
클래스 프록시는 일반적으로 인터페이스를 구현하지 않는 클래스에 주로 사용된다. 하지만 원한다면 인터페이스가 있는 클래스에 클래스 프록시를 강제로 적용할 수도 있다. 이때는 반드시 클래스에 @Transactional을 부여해줘야 한다.
(일정 버전 이상에서는 기본설정이 클래스 프록시임)

#### 클래스 프록시의 제약사항
- 상속을 기반으로 하고 있기 때문에, 클래스 프록시는 final 클래스에는 적용할 수 없다.
- 불필요한 메소드에 트랜잭션이 적용될 수 있다.

### AOP 방식: 프록시와 AspectJ
JDK 다이나믹 프록시든 CGLib든 프록시 기반 AOP이다. 
AspectJ AOP는 이런 방식과 달리 프록시를 타깃 오브젝트 앞에 두지 않는다. 대신 타깃 오브젝트 자체를 조작해서 부가기능을 직접 넣는 방식이다. 마치 처음부터 타깃 오브젝트의 클래스에 부가기능을 가진 소스코드가 있었던 것처럼 만들어준다.
메소드 실행 지점만 조인 포인트로 사용할 수 있는 프록시 방식의 스프링 AOP에서는 불가능한 다양한 조인 포인트와 고급 기능을 이용할 수 있다.

#### 프록시 기반 AOP와 자기호출
프록시기반 AOP에서 부가기능을 적용하기 위해서는, 반드시 타깃 오브젝트가 프록시를 통해서 접근되어야 한다.
따라서 타깃 오브젝트 내에서 내부 메소드를 직접 호출할 경우에는, 프록시를 거치지 않고 타깃오브젝트로 바로 접근하는 것이므로 부가기능이 적용되지 않는다.
이처럼 타깃 오브젝트의 자기 호출에는 AOP가 적용되지 않는다는 점이 프록시 AOP의 한계다. 이를 해결하기 위해 내부 메소드를 호출할 떄도 트랜잭션 프록시를 거치게 해야하는데 다음과 같은 방법을 고려할 수 있다.

1. AopContext.currentProxy()
- 이 기능을 사용하면 타깃 오브젝트에서 현재 진행중인 프록시를 가져올 수 있다. 가져온 프록시를 통해 내부메소드를 호출함으로써 부가기능을 이용하는 것
- 스프링 API가 비즈니스 로직을 가진 POJO클래스 코드에 등장한다는 문제가 있음

2. AspectJ AOP
- 프록시 기반 AOP가 아니라, 바이트코드를 조작하여 부가기능을 적용하므로 타깃오브젝트가 자기 호출을 하더라도 트랜잭션 부가기능이 잘 적용된다.


### 트랜잭션 속성
#### 트랜잭션 전파: propagation
- REQUIRED
	- 디폴트 속성. 미리 시작된 트랜잭션이 있으면 참여 / 없으면 새로 시작한다.
	- 하나의 트랜잭션이 시작된 이후 다른 트랜잭션 메소드를 호출하면 자연스레 같은 트랜잭션으로 묶인다.
- SUPPORTS
	- 이미 시작된 트랜잭션이 있다면 참여 / 그렇지 않으면 그냥 트랜잭션 없이 진행
- MANDATORY
	- REQUIRED와 비슷하게 이미 시작된 트랜잭션이 있다면 참여, 하지만 트랜잭션이 없으면 예외를 발생시킨다.
- REQUIRES_NEW
	- 항상 새로운 트랜잭션을 시작한다. 이미 진행중인 트랜잭션이 있으면 트랜잭션을 잠시 보류시킨다.
- NOT_SUPPORTED
	- 트랜잭션을 사용하지 않게 한다. 이미 진행 중인 트랜잭션이 있다면 보류시킨다.
- NEVER
	- NOT_SUPPRORTED와 비슷하게 트랜잭션을 사용하지 않게 한다. 이미 진행중인 트랜잭션이 있다면 예외를 발생시킨다.
- NESTED
	- 이미 진행 중인 트랜잭션이 있으면 중첩 트랜잭션을 시작한다. 중첩 트랜잭션은 트랜잭션 안에 다시 트랜잭션을 만드는 것으로, 독립적인 트랜잭션을 만드는 REQUIRES_NEW 와는 다르다.
	- 중첩 트랜잭션은 먼저 시작된 부모 트랜잭션의 커밋과 롤백에는 영향을 받지만, 자신의 커밋과 롤백은 부모 트랜잭션에게 영향을 주지 않는다.
	- 예를 들어, 어떤 중요 작업을 진행하는 중에 작업로그를 DB에 저장한다고 가정해보자. 로그저장작업이 실패하더라도 메인작업의 트랜잭션을 롤백해서는 안되는 경우가 있다. 반면에 로그를 남긴 후에 핵심 작업에서 예외가 발생한다면 이때는 저장한 로그도 제거해야 한다. 이럴 때, 로그 작업을 메인 트랜잭션에서 분리해서 중첩 트랜잭션으로 만들면 된다.

#### 트랜잭션 격리수준: isolation
트랜잭션 격리수준은 동시에 여러 트랜잭션이 진행될 때에 트랜잭션의 작업 결과를 여타 트랜잭션에게 어떻게 노출할 것인지를 결정하는 기준이다.
- DEFAULT
	- 사용하는 데이터 액세스 기술 또는 DB드라이버의 디폴트 설정을 따른다.
- READ_UNCOMMITTED
	- 가장 낮은 격리수준. 하나의 트랜잭션이 커밋되기 전에 그 변화가 다른 트랜잭션에 그대로 노출
- READ_COMMITTED
	- 트랜잭션이 커밋하지 않은 정보는 다른 트랜잭션이 읽을 수 없다.
	- 대신 하나의 트랜잭션이 읽은 로우를 다른 트랜잭션이 수정 및 커밋할 수 있고, 처음 트랜잭션이 같은 로우를 여러 번 읽을 때 다른 트랜잭션이 가한 변경때문에 다른 내용이 조회될 수 있다.  
- REPEATABLE_READ
	- 하나의 트랜잭션이 읽은 정보가 다른 트랜잭션에 의해 변경되는 것을 막아준다.(Read/Write 락을 이용할 수도 있지만, 대부분의 현대적인 DB 엔진은 MVCC를 활용하여 락없이 해당 수준을 구현한다.)
- SERIALIZABLE
	- 가장 강력한 격리수준. 트랜잭션을 순차적으로 진행시키기 떄문에 여러 트랜잭션이 동시에 같은 테이블의 정보를 액세스하지 못한다.

#### 트랜잭션 제한시간: timeout
이 속성을 이용하면 트랜잭션에 제한시간을 지정할 수 있다.

#### 읽기전용 트랜잭션: read-only, readOnly
트랜잭션을 읽기전용으로 설정할 수 있다.
성능을 최적화하기 위해 사용할 수도 있고 특정 트랜잭션 작업 안에서 쓰기 작업이 일어나는 것을 의도적으로 방지하기 위해 사용할 수도 있다.
read only 성능최적화는 DB 스토리지 엔진 / DB 이중화 구성 / JPA 엔티티매니저 등 다양한 곳에서 수행될 수 있다.
예외적인 트랜잭션 매니저도 있지만, 일반적으로는 읽기전용 트랜잭션이 시작된 이후 INSERT, UPDATE, DELETE 같은 쓰기 작업이 진행되면 예외가 발생한다. 

#### 트랜잭션 롤백 예외: rollback-for, rollbackFor, rollbackForClassName
선언적 트랜잭션에서는 런타임 예외가 발생하면 롤백한다.
반면에 예외가 전혀 발생하지 않거나 체크 예외가 발생하면 커밋한다. 체크 예외를 커밋 대상으로 삼은 이유는 체크 예외가 예외적인 상황에서 사용되기 보다는 리턴값을 대신해 비즈니스적인 의미를 담은 결과를 돌려주는 용도로 많이 사용되기 때문.
스프링에서 데이터 액세스 기술의 예외는 런타임 예외로 전환돼서 던져지므로 기본설정은 런타임 예외만 롤백대상으로 삼음
원한다면 기본 동작방식을 바꿀 수 있다.

#### 트랜잭션 커밋 예외: no-rollback-for, noRollbackFor, noRollbackForClassName
rollback-for 속성과는 반대로 기본적으로는 롤백 대상인 런타임 예외를 트랜잭션 커밋 대상으로 지정해준다.


### 데이터 액세스 기술 트랜잭션의 통합
스프링은 두 개 이상의 데이터 액세스 기술로 만든 DAO를 하나의 트랜잭션으로 묶어서 사용하는 방법을 제공한다. 물론 이때도 DB당 트랜잭션 매니저는 하나만 사용한다. DB는 하나이지만 두 가지 이상의 데이터 액세스 기술을 동시에 사용하는 경우 활용할 수 있다.

#### 트랜잭션 매니저별 조합 가능 기술
- DataSourceTransactionManager
   - JDBC와 iBatis 두 가지 기술을 함께 사용할 수 있다.
- JpaTransactionManager
   - JPA, JDBC, iBatis 세 가지 기술을 이용하는 DAO 작업을 하나의 트랜잭션으로 관리할 수 있다.
- Hibernate TransactionManager
   - 하이버네이트, JDBC, iBatis 세 가지 기술의 DAO를 통합해서 사용할 수 있다.
- JtaTransactionManager
   - 하나 이상의 DB 또는 JMS와 같은 트랜잭션이 지원되는 서비스를 통합해서 하나의 트랜잭션으로 관리할 수 있다.

#### ORM과 비 ORM DAO를 함께 사용할 때의 주의사항
JPA나 하이버네이트 같은 엔티티 기반의 ORM 기술과 JDBC, iBatis 같은 SQL 기반의 비 ORM 기술을 함께 사용하고 하나의 트랜잭션으로 묶어서 사용하는 것은 기술적으로 볼때 아무런 문제가 없다.
그러나 각 기술의 특징을 잘 이해하지 않으면 예상치 못한 오류를 만날 수 있다.

JPA나 하이버네이트는 단순히 JDBC API를 간접적으로 실행해주는 방식이 아니다. 최종적으로는 JDBC API를 이용하지만 중간과정에서 엔티티를 캐싱하여 관리하고, 필요할 때만 DB와 통신한다.
반면 JDBC, iBatis 같은 기술은 DB와 즉각적으로 통신하기 때문에, DB반영시점에 대한 차이로 의도치 않은 동작이 발생할 수 있다.
(JPA에서 객체를 저장한다고 바로 DB insert구문이 날아가진 않음 -> MyBatis에서 JPA를 통해 등록한 로우를 조회하려할 때 이러한 지연최적화로 인해 예상한 로우를 가져오지 못할 수 있다.)

따라서 이 문제를 해결하기 위해서는
1. JPA의 저장이나 수정 작업을 한 후에는 강제로 캐시의 내용을 DB로 보내주는 EntityManager나 Session의 flush() 메소드를 사용하거나
2. JDBC의 DAO가 호출될 때 flush()하도록 만들어주는 것
둘 중 하나의 방법을 이용해야 한다. 1.의 경우 JPA에서 제공하는 최적화 기능을 충분히 이용할 수 없기 때문에, 2.의 방법이 선호된다.

### JTA를 이용한 글로벌/분산 트랜잭션
한 개 이상의 DB나 JMS의 작업을 하나의 트랜잭션 안에서 동작하게 하려면 서버가 제공하는 트랜잭션 매니저를 JTA를 통해 사용해야 한다.
스프링에서는 서버에 설정해둔 XA DataSource와 트랜잭션 매니저 그리고 UserTransaction 등을 JNDI를 통해 가져와 모든 데이터 액세스 기술에서 사용할 수 있다.

#### 독립형 JTA 트랜잭션 매니저
JTA는 WAS가 제공하는 서비스를 이용하는 경우가 일반적이지만, 원한다면 서버의 지원 없이도 애플리케이션 안에 JTA 서비스 기능을 내장하는 독립형 JTA 방식으로 이용할 수 있다. 이 방식을 사용하면 JTA를 지원하는 WAS가 아닌 톰캣과 같은 서블릿 컨테이너에서도 JTA 기능을 이용하는 것이 

독립형 JTA 트랜잭션 매니저는 ObjectWeb의 JTA 엔진인 JOTM과 Atomikos의 TransactionalEssentials가 대표적이다.

## 정리
- DAO 패턴을 이용하면 데이터 액세스 계층과 서비스 계층을 깔끔하게 분리하고 데이터 액세스 기술을 자유롭게 변경해서 사용할 수 있다.
- 스프링 JDBC는 JDBC DAO를 템플릿/콜백 방식을 이용해 편리하게 작성할 수 있게 해준다.
- SQL 매핑 기능을 제공하는 iBatis로 DAO를 만들 때도 스프링의 템플릿/콜백 지원 기능을 사용할 수 있다.
- JPA와 하이버네이트를 이용하는 DAO에서는 템플릿/콜백과 자체적인 API를 선택적으로 사용할 수 있다.
- 트랜잭션 경계설정은 XML의 스키마 태그와 애노테이션을 이용해 정의할 수 있다. 또한 트랜잭션 AOP를 적용할 때는 프록시와 AspectJ를 사용할 수 있다.
- 스프링은 하나 이상의 데이터 액세스 기술로 만들어진 DAO를 같은 트랜잭션 안에서 동작하도록 만들어준다. 하나 이상의 DB를 사용할 때는 JTA 지원 기능을 활용해야 한다.