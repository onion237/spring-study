# 3장 템플릿

- 1장에서 개선했던 UserDAO에 템플릿 콜백 패턴을 적용하여 추가 개선
- 리소스의 획득(1장에서 다룬 커넥션 생성로직의 분리) 뿐 아니라, 예외처리 및 리소스 반환에 대한 공통 로직(컨텍스트)를 리팩토링하는 과정을 보여주고 있습니다.


## UserDAO클래스의 문제점
- 공유리소스인 Connection 및 PreparedStatement를 예외상황에서도 안전하게 반환하는 예외처리 로직이 없습니다
- 장시간 운영되는 서버프로그램의 경우 공유자원을 적절히 반환하지 않으면 시스템 전체에 장애를 유발할 수 있기 때문에 반드시 공유자원을 반환할 수 있는 예외처리 로직을 개발하여야 합니다.

## 예외처리 로직을 매번 작성하는 것이 맞을까?
- 예외처리 로직은 UserDAO의 주관심사에 해당하는 영역이 아닙니다
- 자원의 획득과 적절한 반환이라는 부가적인 관심사는 UserDAO의 모든 메소드 혹은 다른 DAO클래스에서 중복해서 나타날 수 있는 로직이므로 분리하는 것이 좋습니다.
(1장에서 DB커넥션 획득 방법을 분리하는 이유와 같습니다. 다만 1장에서 다루었던 전형적인 전략패턴과는 조금은 다른 접근이 필요합니다)

## 예외처리 로직을 어떻게 분리할까?
### 1. 메소드 추출
- 중복코드를 제거하기 위해 우선 전체로직에서 변하는 부분과 변하지 않는 부분을 분리합니다.
	- 변하지 않는 부분 : 커넥션 획득 및 반환 / PreparedStatment 실행
	- 변하는 부분 : PreparedStatment생성 및 파라미터 바인딩
- 변하는 부분과 변하지 않는 부분을 분리한 것 까지는 1장과 똑같으나, 차이점이 있습니다
	- 메소드로 추출된 부분이, 중복되는 공통 로직이 아닌 UserDAO클래스의 주관심사인 부분입니다.
	- 1장에서는 커넥션획득이라는 부가적이고 중복되는 로직을 외부로 추출했으나, 예외처리의 경우 중복로직이 중복되지 않는 주관심사 부분을 감싸고 있어, 오히려 주관심사가 외부로 분리된 형태입니다.
- 결과적으로, 분리시킨 메소드를 재사용하는 것이 아닌 분리시키고 남은 메소드를 재사용해야 하는 상황이 됐습니다.

### 2. 템플릿 메소드 패턴 적용
- 예외처리 로직은 UserDAO에서만 쓰이는 로직이 아니기 때문에, 메소드단위 분리를 넘어 클래스를 분리하는 것이 좋습니다.
- 우선은 1장에서와 같이 템플릿 메소드 패턴을 적용하여, 공통 로직인 예외처리부분을 상위 클래스에서 작성하고 해당 템플릿 메소드 내에서 특정 추상메소드를 정해진 시점에 호출하도록 작성 & 하위클래스에서는 정해진 시점에 호출될 추상메소드를 오버라이딩 하도록 작성합니다.
- 이 경우 새로운 메소드가 필요할 때마다 상속을 통해 새로운 클래스를 만들어야 하기 때문에 단점이 많습니다.

### 3. 전략 패턴 적용
- DAO deleteAll 메소드에서 하는 행동은 다음과 같습니다.
	1. DB커넥션 획득
	2. **PreparedStatement 생성** (매번 달라지는 부분 -> 주입될 전략)
	3. PreparedStatement 실행
	4. 예외처리
	5. 커넥션 및 PreparedStatement 반환
- 전략에 해당하는 PreparedStatement 생성부를 외부에서 주입함으로써 전략패턴을 적용할 수 있습니다.
- 1장의 개선방법과 약간의 차이점은, DI의 단위입니다.
- 1장에서는 클래스의 멤버변수에 의존성을 주입하는 클래스 단위 DI가 발생하였다면, 이번에는 메소드마다 전략이 달라지므로 메소드의 매개변수로 의존성을 주입하는 메소드 단위 DI를 활용하였습니다

#### 전략 패턴의 응용
- 1장에서 다룬 문제와의 가장 큰 차이점은 주입될 전략이 공통로직이 아닌, 메소드마다 변경될 로직이라는 점입니다.
- 이 때문에, 1장에서는 주입할 전략의 구현체를 많이 작성할 필요가 없었지만 이번에는 작성되는 모든 DAO메소드마다 전략 구현체를 생성해야 한다는 다른 문제가 생겼습니다.
- 전략 구현체를 별도 클래스 파일로 정의한다면, 메소드 작성마다 클래스파일이 늘어나게 될 것이므로 익명내부클래스(or 람다)를 활용하여 메소드 호출 시점에 전략 구현체 생성 및 인자 전달을 동시에 수행하는 것이 간편합니다.

### 4. 템플릿/콜백 패턴
- 공통로직인 예외처리부를 UserDAO로부터 완전히 분리하여 JdbcContext클래스로 만들고, jdbcContext의 메소드가 매개변수로 전략을 주입받아 동작하도록 변경합니다.
```
- 이때, 인터페이스를 통해서가 아닌 클라이언트가 JdbcContext라는 구체적인 타입에 의존하도록 주입이 일어 났는데, 이는 컨텍스트와 클라이언트가 가진 응집도를 허용할 것인지에 따라 달라질 수 있는 사항입니다.
- 응집도를 낮추고 인터페이스로 풀어낸다는 것은, JdbcContext가 해주는 예외처리라는 공통부로직을 다른 구현으로 교체 및 조립 가능한 형태로 설계한다는 것을 
- 책에서는 DataSource의 예시와는 달리 테스트에서도 다른 구현으로 대체할 이유가 없는 것과, JDBC를 직접 사용하지 않는 다른 방식으로 전환한다면 어짜피 JdbcContext를 통째로 바꿔야하는 것을 이유로 들어 굳이 인터페이스를 두지 않고 강결합을 허용했습니다
-> 구체적인 자원의 획득과 반환 방법(커넥션을 직접 열고 닫을지, 커넥션풀을 사이에 둘지 등등)이라는 개별적 요소는 교체가능한 대상이지만, 자원의 획득과 반환이라는 전체적인 템플릿은 교체될 여지가 거의 없다는 의미로 해석됩니다.   
```

- 이때, JdbcContext의 공통로직은 템플릿, 메소드의 매개변수로 주입되어 정해진 시점에 템플릿으로부터 호출되는 로직을 콜백이라고 부릅니다
- 이처럼, DI 및 전략패턴의 응용이지만 일반적인 전략패턴과는 다른 독특한 특징(전략패턴 + 메소드단위 DI + 익병 내부 클래스 사용의 결합)을 가지고 있으므로 템플릿/콜백 패턴이라고 별도로 지칭합니다.

#### 템플릿 콜백 패턴의 응용
- 지금까지는 콜백이 PreparedStatement객체를 생성하고 파라미터를 바인딩하는 역할까지 담당했지만 해당 기능 또한 템플릿에 들어가야할 기능입니다.
- 엄밀히 따져보았을 때 실제로 변하는 부분은 쿼리문과 바인딩 파라미터이기 때문에, 컨텍스트 메소드를 사용할 때 쿼리문과 파라미터만 전달하고, PreparedStatment를 생성하고 파라미터를 바인딩하는 것은 템플릿에서 하도록 처리합니다.
- DAO가 아닌 계산기 예제에서는, 제네릭을 활용하여 더 다양한 오브젝트 타입을 지원하는 템플릿/콜백 패턴을 설계하는 법을 보여줍니다
-> JDBC를 이용하는 DAO에서 사용할 수 있도록 스프링에서 제공하는 JdbcTemplate또한 템플릿/콜백 패턴을 이용하여 설계되었습니다. 
