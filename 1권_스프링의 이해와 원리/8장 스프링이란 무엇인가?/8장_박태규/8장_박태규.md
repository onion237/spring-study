# 8장 스프링이란 무엇인가?
 ---

## 1.1  스프링의 정의
*  자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크 

### 애플리케이션 프레임워크 
    - 애플리케이션을 빠르고 효율적으로 안정적으로 구축하는데 사용할 수 있는 포괄적인 도구, 구성 요소 및 각 분야의 특성에 맞는 필요를 채워주고 있음

### 경량급 
    - Java Spring 프레임워크 자체가 크고 많은 기능과 구성 요소를 포함, 하지만 "모듈식 설계"를 통해 필요한 구성 요소만 선택하고 사용할 수 있음, 프레임 워크의 전체적인 복잡성과 오버헤드를 최소화하는데 도움이 됨
-> 개발자가 특정 프로젝트에 필요한 구성 요소만 선택하고 사용할 수 있기 때문

### 자바 엔터프라이즈 개발을 편하게
    - 개발자가 복잡하고 실수하기 쉬운 로우레벨 기술에 많은 신경을 쓰지 않게 하며 애플리케이션의 핵심인 비즈니스 로직을 빠르고 효과적으로 구현
-> 프레임워크 기술보다 애플리케이션의 로직에 더 많은 관심과 시간을 쏟게 해줌

### 오픈소스
Apache License 2.0
  + 상업 목적의 제품에 포함 가능, 수정한 소스 공개 의무 x

장점: 투명한 방식으로 다양한 참여, 매우 빠르고 유연한 개발이 가능
  + 비용, 수정 가능, 대규모 개발자 커뮤니티가 있기 때문에 더욱더 빠르고 유연한 개발이 가능함

단점: 지속적이고 안정적인 개발의 불확실함

---
## 1.2 스프링의 목적
* 자바의 근본적인 목적은 객체지향 프로그래밍을 통해 유연하고 확장성 좋은 애플리케이션을 빠르게 만드는 것
* 애플리케이션 개발의 복잡성에 대응하여 편하게 하려는 것 

### 엔터프라이즈 개발의 복잡함
1. 기술적인 제약조건과 요구사항이 늘어남
- 많은 사용자의 요청을 동시에 처리해야 하기 때문에 서버의 자원을 효율적으로 공유하고 분배해서 사용할 수 있어야함, 민감한 데이터를 다룰 때가 많기 때문에 보안 요구 사항도 고려해야 함

2. 비즈니스 로직의 복잡함이 증가함
- 업무적인 변화의 속도가 빠르고 복잡해짐으로 기능 요구사항과 정책이 자주 바뀌고 자주 수정해줘야 함

이 두가지가 복잡하지만 서로 얽혀있기 때문에 더더욱 복잡함

### 복잡함을 해결하려는 도전
제거될 수 없는 근본적인 복잡함
- 엔터프라이즈 개발의 근본적인 복잡함의 원인은 제거할 대상이 되지 못함 현실적으로 불가능하기 때문
- 엔터프라이즈 애플리케이션 자체가 데이터베이스, 메시징 시스템 및 외부 API와 같은 시스템 및 서비스와 통합되어야 하기 때문에

비침투적인 방식을 통한 효과적인 해결
- 핵심 비즈니스 로직과 기술적 복잡함을 분리.
- 개발자가 신경써야하는 비즈니스 로직은 타 기술이 침투하지 않음 -> 객체지향을 통한 복잡성을 감소시키는 방법을 자유롭게 적용할 수 있는 기반이 마련
-> 해당 개체를 수정하지 않고도 스프링을 사용하여 애플리케이션 개체를 구성하고 관리할 수 있음

### 복잡함을 상대하는 스프링의 전략
스프링의 기본적인 전략
- 비즈니스 로직을 담은 애플리케이션 코드와 엔터프라이즈 기술을 처리하는 코드를 분리시키는 것
-> 두 가지 복잡함의 문제를 효과적으로 공략

1. 기술적인 복잡함을 상대하는 전략
문제
- 기술에 대한 접근 방식이 일관성이 없고 특정 환경에 종속적임 
    + 서비스 추상화
        - 트랜잭션 추상화, OXM추상화, 데이터 엑세스에 대한 일관된 예외변환 기능 등
        - 인터페이스 구현, 종속성 주입 등
        - 개발 프로세스를 단순화하고 응용프로그램의 코드 오류 또는 불일치 가능성을 줄임

- 기술적인 처리를 담당하는 코드가 성격이 다른 코드에 섞여서 등장
    + AOP
        - 트랜잭션 관리, 보안적용, 로깅, audit 등
        - 기술과 비즈니스 로직을 분리시킴으로써 복잡성을 감소시키고 중복을 제거함
        - 모듈성을 높이는 것이 목적

2. 비즈니스와 애플리케이션 로직의 복잡함을 상대하는 전략
- 스프링은 객체지향 언어의 장점을 제대로 살리지 못하게 방해했던 요소를 제거하도록 도와줌
    + 객체지향, DI
        - 기술적인 복잡함을 해결하는 문제나 기술적인 복잡함이 비즈니스 로직에 침범하지 못하도록 분리하는 경우 DI
        - 비즈니스 로직 자체의 복잡함을 해결하려면 DI보다는 객체지향 설계기법이 더중요
        - 객체지향 설계 기술이 없다면 DI도 존재 의미가 없음

## POJO 프로그래밍
분리됐지만 반드시 필요한 엔터프라이즈 서비스 기술을 POJO방식으로 개발된 애플리케이션 핵심 로직을 담은 코드에 제공한다는 것이 스프링의 가장 강력한 특징과 목표

### POJO의 정의
Plain Old Java Object 의 약자
프레임워크나 라이브러리에 의존하지 않고 기본 Java 규칙 및 패턴을 준수하는 Java 개체

### POJO의 조건
평범한 자바오브젝트라고 할 수 있지만 두가지 조건을 충족해야 POJO라고 불릴 수 있음 
- 특정 규약에 종속되지 않는다.
    + 자바언어와 꼭 필요한 API외에는 종속되지 않아야함. 
특정 규약을 따라 비즈니스 컴포넌트를 만들어야하는 경우는 POJO가 아님
-> 특정 클래스를 상속하도록 요구하기 때문에 해당 클래스에 객체지향적인 설계 기법을 적용하기 어려워지는 문제가 생김

- 특정 환경에 종속되지 않는다.
    + 특정 OS에서 제공하는 기능을 직접 호출하거나, 특정 환경에 종송적인 클래스나 API를 직접 쓴 경우도 있는데 이런 경우는 POJO라고 할 수 없음
    + 비즈니스 로직을 담고 있는 POJO클래스는 웹이라는 환경 정보나 웹 기술을 담고 있는 클래스/인터페이스를 사용해서는 안됨
        -> 직접적으로 웹이라는 환경으로 제한해버리는 오브젝트나 API에 의존하면 웹 외의 클라이언트가 사용하지 못하고 독립적인 테스트 어려움
        -> 비즈니스 로직을 담은 코드에 HttpServletRequest, HttpSession, 캐시 등을 직접 이용하는 부분이 있다면 진정한 POJO가 아님

- 객체지향적 자바언어의 기본에 충실

진정한 POJO란 객체지향적 원리에 충실하면서, 환경과 기술에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 오브젝트.
-> 이러한 오브젝트를 가지고 애플리케이션의 핵심로직과 기능을 담아 설계하고 개발하는 방법을 POJO 프로그래밍이라 할 수 있음

### POJO의 장점
1. 단순성. 복잡한 종속성이나 프레임워크가 없기 때문에 단순하고 이해하기 쉬움
2. 재사용성. 수정 없이 다른 애플리케이션에서 사용할 수 있음
3. 테스트가능성. 
4. 유지보수성
-> 특정 환경에 종속되지 않고 특정 규약에 종속되지 않기 때문에 

### POJO 프레임워크
스프링은 POJO를 이용한 엔터프라이즈 애플리케이션 개발을 목적으로 하는 프레임워크. POJO프로그래밍이 가능하도록 기술적인 기반을 제공하는 프레임워크를 POJO프레임워크. 기술영역에만 관여하고, 비즈니스 로직을 담당하는 POJO에서는 모습을 감춤. 데이터 액세스 로직이나 웹 UI 로직을 다룰 때만 최소한의 방법으로 관여함


## 스프링의 기술
POJO프로그래밍을 손쉽게할 수 있도록 세 가지 가능 기술
IoC/DI, AOP, PSA

### IoC/DI
- DI를 하는 이유
    + 왜 두개의 오브젝트를 분리하고 인터페이스를 두고 느슨하게 연결한 뒤 실제 사용할 대상은 DI를 통해 외부에서 지정하는가? (직접 개발자가 사용할 오브젝트를 new 키워드로 생성해서 사용하는 강한 결합을 쓰는 방법보다 나은점은?)
        - 유연한 확장을 가능하게 하기 위해
        - DI는 개방 폐쇄 원칙(OCP)이라는 객체지향 설계 원칙으로 설명됨
        - 유연한 확장이라는 장점은 OCP의 확장에는 열려있다에 해당하고 OCP의 변경에는 닫혀있다 라는 말로 설명이 가능함
        - 폐쇄 관점에서 볼 때의 장점은 재사용이 가능하다는 것이 있음

#### DI의 활용 방법
- 핵심기능의 변경
    + DI의 가장 대표적인 적용 방법은 의존 대상의 구현을 바꾸는 것
    + 디자인 패턴의 전략패턴이 대표적인 예
        - 의존하는 서비스의 구현 세부 정보에서 클라이언트 코드를 분리할 수 있기 때문에
    + 실제 의존하는 대상이 가진 핵심 기능을 DI 설정을 통해 변경하는 것이 대표적인 DI의 활용 방법

- 핵심기능의 동적인 변경
    + 동적으로 매번 다르게 변경할 수 있음
    + 기본적으로는 런타임 시에 동적으로 의존 오브젝트를 연결해주는 것이긴 하지만, DI되고 나면 그 후로 바뀌지 않음
        - 동적인 방식으로 연결되지만 한 번 DI되면 바뀌지 않는 정적인 관계를 맺어줌 -> 잘 활용하면 애플리케이션이 동작하는 중간에 그 의존 대상을 동적으로 바꿔줄 수 있음

- 부가기능의 추가
    + 핵심기능은 그대로 둔 채로 부가기능을 추가하는 방식
    + 데코레이터 패턴
    + 인터페이스를 두고 사용하게 하고, 실제 사용할 오브젝트는 외부에서 주입하는 DI를 적용해두면 데코레이터 패턴을 쉽게 적용할 수 있음
        -> 핵심기능과 클라이언트 코드에는 전혀 영향을 주지 않으면서 부가적인 기능을 얼마든지 추가 가능

- 인터페이스의 변경
    + 오브젝트가 가진 인터페이스가 클라이언트와 호환되지 않는 경우, 어댑터 패턴 적용
       예시 A(Client)가 C를 사용하고 싶을때

    + 이걸 일반화해서 인터페이스가 다른 다양한 구현을 같은 방식으로 사용하도록 중간에 인터페이스 어댑터 역할을 하는 레이어를 추가할 수 있음 -> 서비스 추상화

- 프록시
    + 필요한 시점에서 실제 사용할 오브젝트를 초기화하고 리소스를 준비하게 해주는 지연된 로딩을 적용하려면 프록시가 필요함
    + 원격 오브젝트를 호출할 때 마치 로컬에 존재하는 오브젝트처럼 사용할 수 있게 해주는 원격프록시를 적용하려고 할 때에도 프록시가 필요함
    + 이 두가지 방법 모두 DI를 필요로함

- 템플릿과 콜백
    + 항상 고정적인 작업 흐름과 그 사이에서 자주 바뀌는 부분을 정리해서 템플릿과 콜백으로 만듬
    + 콜백은 얼마든지 만들어서 사용할 수 있음 = 개방을 통한 유연한 확장
    + 템플릿은 한 번 만들어두고 계속 재사용  = 확장에도 변하지 않음

- 싱글톤과 오브젝트 스코프
    + DI할 오브젝트의 생명주기를 제어할 수 있음
        -  DI를 프레임워크로 이용하기 때문에 DI 대상 오브젝트를 컨테이너가 관리하고, 생명주기를 컨테이너가 주관하기 때문에 스코프를 자유롭게 제어할 수 있음
    + 스프링의 DI는 기본적으로 싱글톤으로 오브젝트를 만들어서 사용하게 함 
         컨테이너가 알아서 싱글톤으로 만들고 관리하기 때문에 클래스 자체는 싱글톤을 고려하지 않고 자유롭게 설계해도 된다는 장점이 있음

- 테스트
    + 테스트 대상이 의존하는 오브젝트를 수동으로 목 오브젝트를 주입

## 애스펙트 지향 프로그래밍(AOP)
보통 IoC/DI 기법으로 POJO프로그래밍을 하지만, 일부 서비스는 순수한 객체지향기법만으로는 POJO의 조건을 유지한 채로 적용하기 힘듦. -> 이런걸 해결하기 위해 AOP가 필요함.

### AOP의 적용 기법
    1. 스프링처럼 다이내믹 프록시 사용하기
        - 데코레이터 패턴을 응용함. 만들기 쉽고 적용 간편하지만 부가기능을 부여할 수 있는 곳은 메서드 호출이 일어나는 지점으로 한정됨
    2. 자바 언어의 한계를 넘어서는 언어의 확장을 이용하는 방법
        - AspectJ 사용 > 메서드 호출 뿐만아니라 인스턴스 생성, 필드 액세스, 특정 호출 경로를 가진 메서드 호출등에도 부가기능 제공 가능
        - 별도의 AOP 컴파일러를 이용한 빌드 과정을 거치거나, 클래스가 메모리로 로딩될 때 바이트코드를 조작해서 이루어짐. 하지만 사용하기가 까다로움

### 포터블 서비스 추상화 (PSA)
환경과 세부 기술의 변화에 관계없이 일관된 방식으로 기술에 접근할 수 있게 해줌
- 스프링은 JavaEE를 기본플랫폼으로 하는 자바 엔터 프라이즈 개발에 주로 사용됨
    -> 다양한 JavaEE 기술에 의존적일 수 밖에 없음
 
